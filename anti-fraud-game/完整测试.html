<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®Œæ•´åŠŸèƒ½æµ‹è¯• - åè¯ˆå…ˆé”‹</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .test-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .test-title {
            font-size: 24px;
            font-weight: bold;
        }
        .test-status {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        .status-pending { background: #ffc107; color: #000; }
        .status-running { background: #17a2b8; }
        .status-success { background: #28a745; }
        .status-error { background: #dc3545; }
        .test-button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        .test-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        .test-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }
        .result-area {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #17a2b8; }
        .quick-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        .quick-link {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 8px;
            transition: all 0.3s ease;
            text-align: center;
            flex: 1;
            min-width: 150px;
        }
        .quick-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <h1 style="text-align: center; margin-bottom: 30px;">ğŸ›¡ï¸ ã€Šåè¯ˆå…ˆé”‹ã€‹å®Œæ•´åŠŸèƒ½æµ‹è¯•</h1>

    <div class="quick-links">
        <a href="./index.html" class="quick-link" target="_blank">ğŸ® æ¸¸æˆä¸»é¡µ</a>
        <a href="./test.html" class="quick-link" target="_blank">ğŸ§ª åŸºç¡€æµ‹è¯•</a>
        <a href="./init-monitor.html" class="quick-link" target="_blank">ğŸ“Š åˆå§‹åŒ–ç›‘æ§</a>
        <a href="./README.md" class="quick-link" target="_blank">ğŸ“– é¡¹ç›®æ–‡æ¡£</a>
    </div>

    <div class="test-container">
        <div class="test-header">
            <div class="test-title">ğŸš€ è‡ªåŠ¨åŒ–æµ‹è¯•å¥—ä»¶</div>
            <div class="test-status status-pending" id="overall-status">ç­‰å¾…å¼€å§‹</div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div style="text-align: center;">
            <button class="test-button" onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
            <button class="test-button" onclick="runQuickTest()">âš¡ å¿«é€Ÿæµ‹è¯•</button>
            <button class="test-button" onclick="clearResults()">ğŸ—‘ï¸ æ¸…é™¤ç»“æœ</button>
        </div>
        <div class="result-area" id="test-results">
            ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...
        </div>
    </div>

    <div class="test-container">
        <div class="test-header">
            <div class="test-title">ğŸ”§ æ‰‹åŠ¨æµ‹è¯•å·¥å…·</div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
            <button class="test-button" onclick="testGameStart()">æµ‹è¯•æ¸¸æˆå¯åŠ¨</button>
            <button class="test-button" onclick="testScenarioLoading()">æµ‹è¯•åœºæ™¯åŠ è½½</button>
            <button class="test-button" onclick="testStorageOperations()">æµ‹è¯•å­˜å‚¨æ“ä½œ</button>
            <button class="test-button" onclick="testTutorialSystem()">æµ‹è¯•æ•™ç¨‹ç³»ç»Ÿ</button>
            <button class="test-button" onclick="testAchievementSystem()">æµ‹è¯•æˆå°±ç³»ç»Ÿ</button>
            <button class="test-button" onclick="testMobileCompatibility()">æµ‹è¯•ç§»åŠ¨ç«¯å…¼å®¹</button>
        </div>
    </div>

    <div class="test-container">
        <div class="test-header">
            <div class="test-title">ğŸ“Š ç³»ç»Ÿä¿¡æ¯</div>
        </div>
        <div id="system-info">æ­£åœ¨åŠ è½½ç³»ç»Ÿä¿¡æ¯...</div>
    </div>

    <!-- åŠ è½½æ¸¸æˆè„šæœ¬ -->
    <script src="js/device-adaptation.js"></script>
    <script src="js/storage.js"></script>
    <script src="js/scenarios.js"></script>
    <script src="js/tutorial.js"></script>
    <script src="js/game.js"></script>
    <script src="js/debug.js"></script>
    <script src="js/init.js"></script>

    <script>
        let testResults = [];
        let currentTestIndex = 0;
        let totalTests = 0;

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            testResults.push({ message: logEntry, type });
            updateResultsDisplay();
        }

        function updateResultsDisplay() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = testResults.map(result =>
                `<div class="${result.type}">${result.message}</div>`
            ).join('');
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function updateProgress(current, total) {
            const percentage = total > 0 ? (current / total) * 100 : 0;
            document.getElementById('progress-fill').style.width = percentage + '%';
        }

        function updateStatus(status, className) {
            const statusDiv = document.getElementById('overall-status');
            statusDiv.textContent = status;
            statusDiv.className = `test-status status-${className}`;
        }

        async function runAllTests() {
            testResults = [];
            currentTestIndex = 0;
            totalTests = 8;

            updateStatus('è¿è¡Œä¸­', 'running');
            log('ğŸš€ å¼€å§‹å®Œæ•´åŠŸèƒ½æµ‹è¯•...', 'info');

            const tests = [
                testInitialization,
                testStorageOperations,
                testScenarioLoading,
                testTutorialSystem,
                testAchievementSystem,
                testGameLogic,
                testMobileCompatibility,
                testPerformance
            ];

            for (let i = 0; i < tests.length; i++) {
                currentTestIndex = i + 1;
                updateProgress(currentTestIndex, totalTests);

                try {
                    await tests[i]();
                } catch (error) {
                    log(`âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }

                // çŸ­æš‚å»¶è¿Ÿä»¥ä¾¿è§‚å¯Ÿç»“æœ
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            updateProgress(totalTests, totalTests);
            updateStatus('æµ‹è¯•å®Œæˆ', 'success');
            log('ğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆï¼', 'success');
        }

        async function runQuickTest() {
            testResults = [];
            updateStatus('è¿è¡Œä¸­', 'running');
            log('âš¡ å¼€å§‹å¿«é€Ÿæµ‹è¯•...', 'info');

            try {
                await testInitialization();
                await testStorageOperations();
                await testScenarioLoading();
                log('âš¡ å¿«é€Ÿæµ‹è¯•å®Œæˆï¼', 'success');
                updateStatus('æµ‹è¯•å®Œæˆ', 'success');
            } catch (error) {
                log(`âŒ å¿«é€Ÿæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                updateStatus('æµ‹è¯•å¤±è´¥', 'error');
            }
        }

        async function testInitialization() {
            log('ğŸ” æµ‹è¯•æ¨¡å—åˆå§‹åŒ–...', 'info');

            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 30;

                const checkInit = () => {
                    attempts++;

                    if (typeof initManager !== 'undefined') {
                        const status = initManager.getStatus();
                        if (status.initializedModules === status.totalModules) {
                            log(`âœ… åˆå§‹åŒ–æˆåŠŸ: ${status.initializedModules}/${status.totalModules} æ¨¡å—`, 'success');

                            // æ£€æŸ¥å…³é”®å…¨å±€å˜é‡
                            const globals = ['game', 'tutorial', 'storage'];
                            const missingGlobals = globals.filter(g => typeof window[g] === 'undefined');

                            if (missingGlobals.length === 0) {
                                log('âœ… æ‰€æœ‰å…¨å±€å˜é‡å·²æ­£ç¡®åˆ›å»º', 'success');
                                resolve();
                            } else {
                                log(`âŒ ç¼ºå°‘å…¨å±€å˜é‡: ${missingGlobals.join(', ')}`, 'error');
                                reject(new Error('å…¨å±€å˜é‡åˆå§‹åŒ–å¤±è´¥'));
                            }
                        } else if (attempts < maxAttempts) {
                            log(`â³ ç­‰å¾…åˆå§‹åŒ–å®Œæˆ... (${attempts}/${maxAttempts})`, 'warning');
                            setTimeout(checkInit, 1000);
                        } else {
                            log(`âŒ åˆå§‹åŒ–è¶…æ—¶: ${status.initializedModules}/${status.totalModules} æ¨¡å—`, 'error');
                            reject(new Error('åˆå§‹åŒ–è¶…æ—¶'));
                        }
                    } else {
                        log('âŒ åˆå§‹åŒ–ç®¡ç†å™¨æœªåŠ è½½', 'error');
                        reject(new Error('åˆå§‹åŒ–ç®¡ç†å™¨æœªåŠ è½½'));
                    }
                };

                checkInit();
            });
        }

        async function testStorageOperations() {
            log('ğŸ’¾ æµ‹è¯•å­˜å‚¨æ“ä½œ...', 'info');

            if (typeof storage === 'undefined') {
                log('âŒ å­˜å‚¨æ¨¡å—æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                // æµ‹è¯•æ¸¸æˆæ•°æ®å­˜å‚¨
                const testData = { test: 'value', timestamp: Date.now() };
                storage.saveGameData(testData);
                const retrievedData = storage.getGameData();

                if (retrievedData && retrievedData.test === testData.test) {
                    log('âœ… æ¸¸æˆæ•°æ®å­˜å‚¨/è¯»å–æ­£å¸¸', 'success');
                } else {
                    log('âŒ æ¸¸æˆæ•°æ®å­˜å‚¨/è¯»å–å¤±è´¥', 'error');
                }

                // æµ‹è¯•æˆå°±æ•°æ®
                const achievements = storage.getAchievements();
                if (Array.isArray(achievements) && achievements.length > 0) {
                    log(`âœ… æˆå°±æ•°æ®æ­£å¸¸ (${achievements.length} ä¸ªæˆå°±)`, 'success');
                } else {
                    log('âŒ æˆå°±æ•°æ®å¼‚å¸¸', 'error');
                }

            } catch (error) {
                log(`âŒ å­˜å‚¨æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testScenarioLoading() {
            log('ğŸ“– æµ‹è¯•åœºæ™¯æ•°æ®åŠ è½½...', 'info');

            if (typeof game === 'undefined' || !game.scenarioManager) {
                log('âŒ æ¸¸æˆæˆ–åœºæ™¯ç®¡ç†å™¨æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                // æµ‹è¯•åœºæ™¯ç®¡ç†å™¨
                const scenario = game.scenarioManager.getRandomScenario();
                if (scenario && scenario.id && scenario.choices) {
                    log('âœ… åœºæ™¯æ•°æ®åŠ è½½æ­£å¸¸', 'success');
                    log(`ğŸ“‹ æµ‹è¯•åœºæ™¯: ${scenario.title}`, 'info');
                } else {
                    log('âŒ åœºæ™¯æ•°æ®åŠ è½½å¤±è´¥', 'error');
                }

                // æµ‹è¯•åœºæ™¯ç±»å‹
                const types = ['phone', 'sms', 'network', 'social'];
                types.forEach(type => {
                    const scenarios = game.scenarioManager.getScenariosByType(type);
                    if (scenarios && scenarios.length > 0) {
                        log(`âœ… ${type} ç±»å‹åœºæ™¯: ${scenarios.length} ä¸ª`, 'success');
                    } else {
                        log(`âŒ ${type} ç±»å‹åœºæ™¯åŠ è½½å¤±è´¥`, 'error');
                    }
                });

            } catch (error) {
                log(`âŒ åœºæ™¯æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testTutorialSystem() {
            log('ğŸ“š æµ‹è¯•æ•™ç¨‹ç³»ç»Ÿ...', 'info');

            if (typeof tutorial === 'undefined') {
                log('âŒ æ•™ç¨‹æ¨¡å—æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                // æµ‹è¯•æ•™ç¨‹æ•°æ®
                const progress = tutorial.getProgress();
                if (progress && progress.totalLessons > 0) {
                    log(`âœ… æ•™ç¨‹æ•°æ®æ­£å¸¸ (${progress.totalLessons} ä¸ªè¯¾ç¨‹)`, 'success');
                } else {
                    log('âŒ æ•™ç¨‹æ•°æ®å¼‚å¸¸', 'error');
                }

                // æµ‹è¯•æ¨èç³»ç»Ÿ
                const recommendations = tutorial.getRecommendedLessons();
                if (Array.isArray(recommendations)) {
                    log(`âœ… æ¨èç³»ç»Ÿæ­£å¸¸ (${recommendations.length} ä¸ªæ¨è)`, 'success');
                } else {
                    log('âŒ æ¨èç³»ç»Ÿå¼‚å¸¸', 'error');
                }

            } catch (error) {
                log(`âŒ æ•™ç¨‹æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testAchievementSystem() {
            log('ğŸ† æµ‹è¯•æˆå°±ç³»ç»Ÿ...', 'info');

            if (typeof storage === 'undefined') {
                log('âŒ å­˜å‚¨æ¨¡å—æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                const achievements = storage.getAchievements();
                if (Array.isArray(achievements)) {
                    log(`âœ… æˆå°±ç³»ç»Ÿæ­£å¸¸ (${achievements.length} ä¸ªæˆå°±)`, 'success');

                    // æ£€æŸ¥æˆå°±ç»“æ„
                    const validAchievements = achievements.filter(a =>
                        a.id && a.name && a.description && a.icon
                    );

                    if (validAchievements.length === achievements.length) {
                        log('âœ… æ‰€æœ‰æˆå°±æ•°æ®ç»“æ„å®Œæ•´', 'success');
                    } else {
                        log(`âš ï¸ ${achievements.length - validAchievements.length} ä¸ªæˆå°±æ•°æ®ä¸å®Œæ•´`, 'warning');
                    }
                } else {
                    log('âŒ æˆå°±ç³»ç»Ÿå¼‚å¸¸', 'error');
                }

            } catch (error) {
                log(`âŒ æˆå°±æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testGameLogic() {
            log('ğŸ® æµ‹è¯•æ¸¸æˆé€»è¾‘...', 'info');

            if (typeof game === 'undefined') {
                log('âŒ æ¸¸æˆæ¨¡å—æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                // æµ‹è¯•å±å¹•åˆ‡æ¢
                const originalScreen = game.currentScreen;
                game.switchScreen('tutorial-screen');

                setTimeout(() => {
                    if (game.currentScreen === 'tutorial-screen') {
                        log('âœ… å±å¹•åˆ‡æ¢åŠŸèƒ½æ­£å¸¸', 'success');
                        game.switchScreen(originalScreen);
                    } else {
                        log('âŒ å±å¹•åˆ‡æ¢åŠŸèƒ½å¼‚å¸¸', 'error');
                    }
                }, 100);

                // æµ‹è¯•æ¸¸æˆæ•°æ®æ›´æ–°
                const originalScore = game.currentScore;
                game.currentScore = 100;

                if (game.currentScore === 100) {
                    log('âœ… æ¸¸æˆçŠ¶æ€ç®¡ç†æ­£å¸¸', 'success');
                    game.currentScore = originalScore; // æ¢å¤åŸå§‹åˆ†æ•°
                } else {
                    log('âŒ æ¸¸æˆçŠ¶æ€ç®¡ç†å¼‚å¸¸', 'error');
                }

            } catch (error) {
                log(`âŒ æ¸¸æˆé€»è¾‘æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testMobileCompatibility() {
            log('ğŸ“± æµ‹è¯•ç§»åŠ¨ç«¯å…¼å®¹æ€§...', 'info');

            try {
                // æµ‹è¯•è®¾å¤‡é€‚é…ç®¡ç†å™¨
                if (typeof deviceAdapter !== 'undefined') {
                    log('âœ… è®¾å¤‡é€‚é…ç®¡ç†å™¨å·²åŠ è½½', 'success');

                    const deviceInfo = deviceAdapter.getDeviceInfo();
                    log(`ğŸ“Š è®¾å¤‡ç±»å‹: ${deviceInfo.type}`, 'info');
                    log(`ğŸ‘† åŸç”Ÿè§¦æ‘¸æ”¯æŒ: ${deviceInfo.touchSupported ? 'æ˜¯' : 'å¦'}`, 'info');
                    log(`ğŸ–±ï¸ é¼ æ ‡æ”¯æŒ: ${deviceInfo.mouseSupported ? 'æ˜¯' : 'å¦'}`, 'info');
                    log(`ğŸ“ å±å¹•æ–¹å‘: ${deviceInfo.orientation}`, 'info');
                    log(`ğŸ“ å±å¹•å°ºå¯¸: ${deviceInfo.windowWidth}x${deviceInfo.windowHeight}`, 'info');

                    // æ£€æŸ¥æ¡Œé¢æ¨¡å¼è§¦æ‘¸æ¨¡æ‹Ÿ
                    if (!deviceInfo.touchSupported && deviceInfo.mouseSupported) {
                        log('âœ… æ¡Œé¢æµè§ˆå™¨ - å·²å¯ç”¨é¼ æ ‡æ¨¡æ‹Ÿè§¦æ‘¸æ“ä½œ', 'success');
                    }
                } else {
                    log('âŒ è®¾å¤‡é€‚é…ç®¡ç†å™¨æœªåŠ è½½', 'error');
                }

                // æµ‹è¯•è§†å£è®¾ç½®
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    log('âœ… è§†å£metaæ ‡ç­¾å·²è®¾ç½®', 'success');
                } else {
                    log('âš ï¸ è§†å£metaæ ‡ç­¾æœªè®¾ç½®', 'warning');
                }

                // æµ‹è¯•åŸç”Ÿè§¦æ‘¸äº‹ä»¶æ”¯æŒ
                if ('ontouchstart' in window) {
                    log('âœ… åŸç”Ÿè§¦æ‘¸äº‹ä»¶æ”¯æŒ', 'success');
                } else {
                    log('â„¹ï¸ åŸç”Ÿè§¦æ‘¸äº‹ä»¶ä¸æ”¯æŒï¼Œä½¿ç”¨é¼ æ ‡æ¨¡æ‹Ÿ', 'info');
                }

                // æµ‹è¯•CSSåª’ä½“æŸ¥è¯¢
                if (window.matchMedia) {
                    log('âœ… CSSåª’ä½“æŸ¥è¯¢æ”¯æŒ', 'success');
                } else {
                    log('âŒ CSSåª’ä½“æŸ¥è¯¢ä¸æ”¯æŒ', 'error');
                }

                // æµ‹è¯•å±å¹•æ–¹å‘API
                if (screen.orientation) {
                    log('âœ… å±å¹•æ–¹å‘APIæ”¯æŒ', 'success');
                } else {
                    log('âš ï¸ å±å¹•æ–¹å‘APIä¸æ”¯æŒ', 'warning');
                }

                // æ£€æŸ¥è®¾å¤‡ç±»å‹CSSç±»
                const body = document.body;
                const deviceClasses = ['device-mobile', 'device-tablet', 'device-desktop'];
                const hasDeviceClass = deviceClasses.some(cls => body.classList.contains(cls));

                if (hasDeviceClass) {
                    const currentDeviceClass = deviceClasses.find(cls => body.classList.contains(cls));
                    log(`âœ… è®¾å¤‡ç±»å‹CSSç±»å·²åº”ç”¨: ${currentDeviceClass}`, 'success');
                } else {
                    log('âŒ è®¾å¤‡ç±»å‹CSSç±»æœªåº”ç”¨', 'error');
                }

                // æ£€æŸ¥è§¦æ‘¸æ¨¡æ‹Ÿå…ƒç´ 
                const touchSimulatedElements = document.querySelectorAll('.touch-simulated');
                if (touchSimulatedElements.length > 0) {
                    log(`âœ… è§¦æ‘¸æ¨¡æ‹Ÿå·²åº”ç”¨åˆ° ${touchSimulatedElements.length} ä¸ªå…ƒç´ `, 'success');
                } else {
                    log('âš ï¸ è§¦æ‘¸æ¨¡æ‹Ÿå…ƒç´ æœªæ£€æµ‹åˆ°', 'warning');
                }

            } catch (error) {
                log(`âŒ ç§»åŠ¨ç«¯å…¼å®¹æ€§æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testPerformance() {
            log('âš¡ æµ‹è¯•æ€§èƒ½...', 'info');

            try {
                const startTime = performance.now();

                // æµ‹è¯•åœºæ™¯åŠ è½½æ€§èƒ½
                if (game && game.scenarioManager) {
                    const scenario = game.scenarioManager.getRandomScenario();
                    const scenarioLoadTime = performance.now() - startTime;

                    if (scenarioLoadTime < 100) {
                        log(`âœ… åœºæ™¯åŠ è½½æ€§èƒ½ä¼˜ç§€ (${scenarioLoadTime.toFixed(2)}ms)`, 'success');
                    } else {
                        log(`âš ï¸ åœºæ™¯åŠ è½½æ€§èƒ½ä¸€èˆ¬ (${scenarioLoadTime.toFixed(2)}ms)`, 'warning');
                    }
                }

                // æµ‹è¯•å†…å­˜ä½¿ç”¨
                if (performance.memory) {
                    const memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                    if (memoryUsage < 50) {
                        log(`âœ… å†…å­˜ä½¿ç”¨è‰¯å¥½ (${memoryUsage.toFixed(2)}MB)`, 'success');
                    } else {
                        log(`âš ï¸ å†…å­˜ä½¿ç”¨è¾ƒé«˜ (${memoryUsage.toFixed(2)}MB)`, 'warning');
                    }
                }

            } catch (error) {
                log(`âŒ æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ‰‹åŠ¨æµ‹è¯•å‡½æ•°
        function testGameStart() {
            if (typeof game !== 'undefined') {
                try {
                    game.startGame();
                    log('âœ… æ¸¸æˆå¯åŠ¨æˆåŠŸ', 'success');
                } catch (error) {
                    log(`âŒ æ¸¸æˆå¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
                }
            } else {
                log('âŒ æ¸¸æˆæ¨¡å—æœªåˆå§‹åŒ–', 'error');
            }
        }

        function testScenarioLoading() {
            testScenarioLoading();
        }

        function testStorageOperations() {
            testStorageOperations();
        }

        function testTutorialSystem() {
            testTutorialSystem();
        }

        function testAchievementSystem() {
            testAchievementSystem();
        }

        function testMobileCompatibility() {
            testMobileCompatibility();
        }

        function clearResults() {
            testResults = [];
            updateResultsDisplay();
            updateProgress(0, 0);
            updateStatus('ç­‰å¾…å¼€å§‹', 'pending');
            document.getElementById('test-results').innerHTML = 'ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...';
        }

        // åŠ è½½ç³»ç»Ÿä¿¡æ¯
        function loadSystemInfo() {
            const info = [
                `ğŸ“± ç”¨æˆ·ä»£ç†: ${navigator.userAgent.substring(0, 100)}...`,
                `ğŸ–¥ï¸ å±å¹•åˆ†è¾¨ç‡: ${screen.width}x${screen.height}`,
                `ğŸŒ è¯­è¨€: ${navigator.language}`,
                `ğŸ“¦ æœ¬åœ°å­˜å‚¨: ${typeof Storage !== 'undefined' ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`,
                `ğŸ¨ CSSåª’ä½“æŸ¥è¯¢: ${window.matchMedia ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`,
                `ğŸ‘† è§¦æ‘¸æ”¯æŒ: ${'ontouchstart' in window ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`,
                `ğŸ”„ å±å¹•æ–¹å‘: ${screen.orientation ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`,
                `âš¡ è¿æ¥ç±»å‹: ${navigator.connection ? navigator.connection.effectiveType : 'æœªçŸ¥'}`
            ];

            document.getElementById('system-info').innerHTML = info.map(item =>
                `<div style="margin: 5px 0;">${item}</div>`
            ).join('');
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            loadSystemInfo();
            log('ğŸ¯ æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ', 'info');

            // ç­‰å¾…æ¸¸æˆåˆå§‹åŒ–
            setTimeout(() => {
                if (typeof initManager !== 'undefined') {
                    log('ğŸ”— æ£€æµ‹åˆ°æ¸¸æˆåˆå§‹åŒ–ç®¡ç†å™¨', 'info');
                }
            }, 2000);
        });

        // ç›‘å¬æ¸¸æˆåˆå§‹åŒ–å®Œæˆ
        window.addEventListener('gameInitialized', () => {
            log('ğŸ‰ æ£€æµ‹åˆ°æ¸¸æˆåˆå§‹åŒ–å®Œæˆäº‹ä»¶', 'success');
            loadSystemInfo();
        });
    </script>
</body>
</html>